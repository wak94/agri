# ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„ é”¯é½¿å½¢å±‚åºéå† ã€‚ï¼ˆå³å…ˆä»å·¦å¾€å³ï¼Œå†ä»å³å¾€å·¦è¿›è¡Œä¸‹ä¸€å±‚éå†ï¼Œä»¥æ­¤ç±»æ¨ï¼Œå±‚ä¸å±‚ä¹‹é—´äº¤æ›¿è¿›è¡Œï¼‰ã€‚ 
# 
#  
# 
#  ç¤ºä¾‹ 1ï¼š 
#  
#  
# è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
# è¾“å‡ºï¼š[[3],[20,9],[15,7]]
#  
# 
#  ç¤ºä¾‹ 2ï¼š 
# 
#  
# è¾“å…¥ï¼šroot = [1]
# è¾“å‡ºï¼š[[1]]
#  
# 
#  ç¤ºä¾‹ 3ï¼š 
# 
#  
# è¾“å…¥ï¼šroot = []
# è¾“å‡ºï¼š[]
#  
# 
#  
# 
#  æç¤ºï¼š 
# 
#  
#  æ ‘ä¸­èŠ‚ç‚¹æ•°ç›®åœ¨èŒƒå›´ [0, 2000] å†… 
#  -100 <= Node.val <= 100 
#  
# 
#  Related Topics æ ‘ å¹¿åº¦ä¼˜å…ˆæœç´¢ äºŒå‰æ ‘ ğŸ‘ 736 ğŸ‘ 0
from typing import Optional, List


# leetcode submit region begin(Prohibit modification and deletion)
# Definition for a binary tree node.
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution:
    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        ans = []
        if not root:
            return ans
        q = [root]
        ans = []
        # Trueè¡¨ç¤ºä»å·¦å¾€å³
        flag = True
        while q:
            v = []
            val = []
            for x in q:
                val.append(x.val)
                if x.left:
                    v.append(x.left)
                if x.right:
                    v.append(x.right)
            q = v
            if not flag:
                val = val[::-1]
            flag = not flag
            ans.append(val)
        return ans
# leetcode submit region end(Prohibit modification and deletion)
